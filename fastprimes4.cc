#include <iostream>
#include <cstdint>
#include <vector>
#include <array>
#include <cassert>

// Prime index.
// Index  Prime
// 0      2
// 1      3
// 2      5
// ...
using prime_index_t = int;

// A prime.
using prime_t = uint32_t;

// A large integer.
using integer_t = uint64_t;     // Must be able to contain the square of the largest prime that we use.

// A distance between two primes.
using prime_gap_t = prime_t;

// List of primes.
using primes_t = std::vector<prime_t>;

// All primes generated so far.
primes_t primes;

int number_of_gaps = 0;

// A class representing a factory for integers that are free
// of prime cofactors up till and including a given prime.
class PrimeBoundCofactorFreeIntegers
{
 private:
  prime_index_t index_;                  // The index of the highest prime that is not a factor of these integers.
  prime_t p_;                            // The highest prime that is not a factor of these integers.
  PrimeBoundCofactorFreeIntegers* prev_; // Pointer to the PrimeBoundCofactorFreeIntegers of the previous prime.
  integer_t sum_;                        // The sum of all gaps.
  size_t max_number_of_gaps_;            // After this many gaps, they start to repeat.
  std::vector<prime_gap_t> gaps_;        // The gaps between the integers.

  int gap_index_{0};
  int failure_index_{0};                 // The index into previous gaps_ that gives us the factor for the next_failure_.
  integer_t current_{1};                 // The last number generated by this factory (free of prime cofactors up till and including p_).
  integer_t next_failure_{p_};           // The next value that will be generated that has incorrectly a factor of p_.

 public:
  PrimeBoundCofactorFreeIntegers() : index_(0), p_(1), prev_(nullptr), sum_(1), max_number_of_gaps_(1), gaps_(1, 1) { }
  PrimeBoundCofactorFreeIntegers(prime_index_t index, PrimeBoundCofactorFreeIntegers* prev);
  ~PrimeBoundCofactorFreeIntegers()
  {
    if (prev_)
      delete prev_;
  }

  integer_t sum() const
  {
    return sum_;
  }

  size_t max_number_of_gaps() const
  {
    return max_number_of_gaps_;
  }

  prime_gap_t first_gap() const
  {
    return gaps_[0];
  }

  void reset()
  {
    gap_index_ = 0;

    if (index_ > 0)
      prev_->reset();
  }

  prime_gap_t next()
  {
    if (gap_index_ < gaps_.size())
      return gaps_[gap_index_++];

    if (gap_index_ == max_number_of_gaps_)
    {
      gap_index_ = 1;
      return gaps_[0];
    }

    // For p_ is 5:
    //   1                   5
    //   5  7 11 13 17 19 23 25 29 31
    // { 4+ 2  4  2  4  2  4 2+  4  2 }

    prime_gap_t gap = prev_->next();
    current_ += gap;
    if (current_ == next_failure_)
    {
      prime_gap_t g = prev_->next();
      gap += g;
      current_ += g;
      next_failure_ += p_ * prev_->get_gap(failure_index_++);
    }
    gaps_.push_back(gap);

    if (gaps_.size() == max_number_of_gaps_)
      std::cout << *this << std::endl;

    return gaps_[gap_index_++];
  }

  prime_gap_t get_gap(int failure_index)
  {
    assert(failure_index < gaps_.size());
    return gaps_[failure_index];
  }

  prime_t next_prime(PrimeBoundCofactorFreeIntegers*& sieve)
  {
    assert(this == sieve);
    std::cout << "Entering next_prime(&" << *sieve << ")" << std::endl;

    // This is code duplication of next(), but heavily adjusted to generate
    // the next prime assuming there is no next sieve above this one.

    if (gap_index_ < gaps_.size())
    {
      // This should only happen for the first (default constructed) sieve.
      ++gap_index_;
      current_ = 2;
    }
    else
    {
      if (gap_index_ == max_number_of_gaps_)
      {
        assert(max_number_of_gaps_ == 1);
        // This should only happen when max_number_of_gaps_ equals 1 (the first two sieves).
        gap_index_ = 1;
        if (++current_ == 3)
          // Create a new sieve before the failure '4'.
          sieve = new PrimeBoundCofactorFreeIntegers(index_ + 1, sieve);
      }
      else
      {
        prime_gap_t gap = prev_->next();
        current_ += gap;
        if (current_ == next_failure_)
        {
          prime_gap_t g = prev_->next();
          gap += g;
          current_ += g;
          next_failure_ += p_ * prev_->get_gap(failure_index_++);
        }
        gaps_.push_back(gap);

        if (gaps_.size() == max_number_of_gaps_)
          std::cout << *this << std::endl;

        ++gap_index_;
      }
    }

    prime_t prime = current_;
    std::cout << "next_prime: " << prime << std::endl;
    return prime;
  }

  void print_on(std::ostream& os) const;
  friend std::ostream& operator<<(std::ostream& os, PrimeBoundCofactorFreeIntegers const& sieve)
  {
    sieve.print_on(os);
    return os;
  }
};

PrimeBoundCofactorFreeIntegers::PrimeBoundCofactorFreeIntegers(prime_index_t index, PrimeBoundCofactorFreeIntegers* prev) :
  index_(index), p_(primes[index]), prev_(prev)
{
  std::cout << "Calling PrimeBoundCofactorFreeIntegers(" << index << ", " << prev << ")" << std::endl;

  sum_ = prev->sum() * p_;
  max_number_of_gaps_ = prev->max_number_of_gaps() * (p_ - 1);
}

int main()
{
  // Bootstrap.
  PrimeBoundCofactorFreeIntegers* sieve = new PrimeBoundCofactorFreeIntegers;
  primes.push_back(1);

  for (int i = 0; i < 10; ++i)
    primes.push_back(sieve->next_prime(sieve));

  delete sieve;
}

void PrimeBoundCofactorFreeIntegers::print_on(std::ostream& os) const
{
  os << "{p_ = " << p_;
  os << " {";
#if 1
  for (auto g : gaps_)
    os << ' ' << g;
#endif
  os << "; sum = " << sum_ << ", #el = " << gaps_.size();
  if (gaps_.size() != max_number_of_gaps_)
    os << "; max#gaps = " << max_number_of_gaps_;
  os << " }";

#if 1
  if (!gaps_.empty())
  {
    integer_t n = 1;
    int gi = 0;
    integer_t end = (gaps_[0] + 1) * (gaps_[0] + 1);
    while (n <= end)
    {
      os << ' ' << n;
      n += gaps_[gi];
      if (++gi == gaps_.size())
      {
        if (gi == max_number_of_gaps_)
          gi = 0;
        else
          break;
      }
    }
  }
#endif
  os << '}';
}
